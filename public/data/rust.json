[
  {
    "categoryName": "Basics",
    "snippets": [
      {
        "title": "Hello, World!",
        "description": "Prints Hello, World! to the terminal.",
        "code": [
          "fn main() { // Defines the main running function",
          "    println!(\"Hello, World!\"); // Prints Hello, World! to the terminal.",
          "}"
        ],
        "tags": ["rust", "printing", "hello-world", "utility"],
        "author": "James-Beans"
      }
    ]
  },
  {
    "categoryName": "String Manipulation",
    "snippets": [
      {
        "title": "Capitalize String",
        "description": "Makes the first letter of a string uppercase.",
        "code": [
          "fn capitalized(str: &str) -> String {",
          "    let mut chars = str.chars();",
          "    match chars.next() {",
          "        None => String::new(),",
          "        Some(f) => f.to_uppercase().chain(chars).collect(),",
          "    }",
          "}",
          "",
          "// Usage:",
          "assert_eq!(capitalized(\"lower_case\"), \"Lower_case\")"
        ],
        "tags": ["rust", "string", "capitalize", "utility"],
        "author": "Mathys-Gasnier"
      },
      {
        "title": "String to Vec<char>",
        "description": "Convert a String into a vector of characters",
        "code": [
          "fn string_to_chars(s: &str) -> Vec<char> {",
          "    s.chars().collect()",
          "}",
          "",
          "// Usage:",
          "let chars = string_to_chars(\"Hello\"); // ['H', 'e', 'l', 'l', 'o']"
        ],
        "tags": ["rust", "string", "vector", "chars"],
        "author": "pyyupsk"
      }
    ]
  },
  {
    "categoryName": "File Handling",
    "snippets": [
      {
        "title": "Read File Lines",
        "description": "Reads all lines from a file and returns them as a vector of strings.",
        "code": [
          "fn read_lines(file_name: &str) -> std::io::Result<Vec<String>>",
          "    Ok(",
          "        std::fs::read_to_string(file_name)?",
          "            .lines()",
          "            .map(String::from)",
          "            .collect()",
          "    )",
          "}",
          "",
          "// Usage:",
          "let lines = read_lines(\"path/to/file.txt\").expect(\"Failed to read lines from file\")"
        ],
        "tags": ["rust", "file", "read", "utility"],
        "author": "Mathys-Gasnier"
      },
      {
        "title": "Find Files",
        "description": "Finds all files of the specified extension within a given directory.",
        "code": [
          "fn find_files(directory: &str, file_type: &str) -> std::io::Result<Vec<std::path::PathBuf>> {",
          "    let mut result = vec![];",
          "",
          "    for entry in std::fs::read_dir(directory)? {",
          "        let dir = entry?;",
          "        let path = dir.path();",
          "        if dir.file_type().is_ok_and(|t| !t.is_file()) &&",
          "            path.extension().is_some_and(|ext| ext != file_type) {",
          "            continue;",
          "        }",
          "        result.push(path)",
          "    }",
          "",
          "    Ok(result)",
          "}",
          "",
          "// Usage:",
          "let files = find_files(\"/path/to/your/directory\", \".pdf\")"
        ],
        "tags": ["rust", "file", "search"],
        "author": "Mathys-Gasnier"
      }
    ]
  },
  {
    "categoryName": "Concurrency",
    "snippets": [
      {
        "title": "Thread Pool Implementation",
        "description": "A simple thread pool implementation for parallel task execution",
        "code": [
          "use std::sync::{mpsc, Arc, Mutex};",
          "use std::thread;",
          "",
          "type Job = Box<dyn FnOnce() + Send + 'static>;",
          "",
          "pub struct ThreadPool {",
          "    workers: Vec<Worker>,",
          "    sender: Option<mpsc::Sender<Job>>,",
          "}",
          "",
          "struct Worker {",
          "    id: usize,",
          "    thread: Option<thread::JoinHandle<()>>,",
          "}",
          "",
          "impl ThreadPool {",
          "    pub fn new(size: usize) -> ThreadPool {",
          "        assert!(size > 0);",
          "",
          "        let (sender, receiver) = mpsc::channel();",
          "        let receiver = Arc::new(Mutex::new(receiver));",
          "        let mut workers = Vec::with_capacity(size);",
          "",
          "        for id in 0..size {",
          "            workers.push(Worker::new(id, Arc::clone(&receiver)));",
          "        }",
          "",
          "        ThreadPool {",
          "            workers,",
          "            sender: Some(sender),",
          "        }",
          "    }",
          "",
          "    pub fn execute<F>(&self, f: F)",
          "    where",
          "        F: FnOnce() + Send + 'static,",
          "    {",
          "        let job = Box::new(f);",
          "        self.sender.as_ref().unwrap().send(job).unwrap();",
          "    }",
          "}",
          "",
          "impl Worker {",
          "    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {",
          "        let thread = thread::spawn(move || loop {",
          "            let message = receiver.lock().unwrap().recv();",
          "",
          "            match message {",
          "                Ok(job) => {",
          "                    println!(\"Worker {id} got a job; executing.\");",
          "                    job();",
          "                }",
          "                Err(_) => {",
          "                    println!(\"Worker {id} disconnected; shutting down.\");",
          "                    break;",
          "                }",
          "            }",
          "        });",
          "",
          "        Worker {",
          "            id,",
          "            thread: Some(thread),",
          "        }",
          "    }",
          "}",
          "",
          "impl Drop for ThreadPool {",
          "    fn drop(&mut self) {",
          "        drop(self.sender.take());",
          "",
          "        for worker in &mut self.workers {",
          "            if let Some(thread) = worker.thread.take() {",
          "                thread.join().unwrap();",
          "            }",
          "        }",
          "    }",
          "}"
        ],
        "tags": ["rust", "concurrency", "thread-pool", "parallel"],
        "author": "pyyupsk"
      }
    ]
  },
  {
    "categoryName": "Advanced Patterns",
    "snippets": [
      {
        "title": "Type-Safe Builder Pattern",
        "description": "Implements a compile-time type-safe builder pattern using phantom types",
        "code": [
          "use std::marker::PhantomData;",
          "",
          "#[derive(Debug)]",
          "pub struct Builder<Name, Age> {",
          "    name: Option<String>,",
          "    age: Option<u32>,",
          "    _name: PhantomData<Name>,",
          "    _age: PhantomData<Age>,",
          "}",
          "",
          "pub struct Missing;",
          "pub struct Set;",
          "",
          "#[derive(Debug)]",
          "pub struct Person {",
          "    name: String,",
          "    age: u32,",
          "}",
          "",
          "impl Default for Builder<Missing, Missing> {",
          "    fn default() -> Self {",
          "        Self {",
          "            name: None,",
          "            age: None,",
          "            _name: PhantomData,",
          "            _age: PhantomData,",
          "        }",
          "    }",
          "}",
          "",
          "impl<Age> Builder<Missing, Age> {",
          "    pub fn name(self, name: impl Into<String>) -> Builder<Set, Age> {",
          "        Builder {",
          "            name: Some(name.into()),",
          "            age: self.age,",
          "            _name: PhantomData,",
          "            _age: PhantomData,",
          "        }",
          "    }",
          "}",
          "",
          "impl<Name> Builder<Name, Missing> {",
          "    pub fn age(self, age: u32) -> Builder<Name, Set> {",
          "        Builder {",
          "            name: self.name,",
          "            age: Some(age),",
          "            _name: PhantomData,",
          "            _age: PhantomData,",
          "        }",
          "    }",
          "}",
          "",
          "impl Builder<Set, Set> {",
          "    pub fn build(self) -> Person {",
          "        Person {",
          "            name: self.name.unwrap(),",
          "            age: self.age.unwrap(),",
          "        }",
          "    }",
          "}",
          "",
          "// Usage:",
          "let person = Builder::default()",
          "    .name(\"John\")",
          "    .age(30)",
          "    .build();"
        ],
        "tags": ["rust", "design-pattern", "builder", "type-safe"],
        "author": "pyyupsk"
      }
    ]
  },
  {
    "categoryName": "Async Programming",
    "snippets": [
      {
        "title": "Async Rate Limiter",
        "description": "Implementation of a token bucket rate limiter for async operations",
        "code": [
          "use std::sync::Arc;",
          "use tokio::sync::Semaphore;",
          "use tokio::time::{interval, Duration};",
          "",
          "pub struct RateLimiter {",
          "    semaphore: Arc<Semaphore>,",
          "}",
          "",
          "impl RateLimiter {",
          "    pub fn new(rate: u32, interval: Duration) -> Self {",
          "        let semaphore = Arc::new(Semaphore::new(rate as usize));",
          "        let sem_clone = semaphore.clone();",
          "",
          "        tokio::spawn(async move {",
          "            let mut ticker = interval(interval);",
          "            loop {",
          "                ticker.tick().await;",
          "                sem_clone.add_permits(rate as usize);",
          "            }",
          "        });",
          "",
          "        RateLimiter { semaphore }",
          "    }",
          "",
          "    pub async fn acquire(&self) -> RateLimit {",
          "        let permit = self.semaphore.acquire().await.unwrap();",
          "        RateLimit { _permit: permit }",
          "    }",
          "}",
          "",
          "pub struct RateLimit<'a> {",
          "    _permit: tokio::sync::SemaphorePermit<'a>,",
          "}",
          "",
          "// Usage:",
          "async fn example() {",
          "    let limiter = RateLimiter::new(10, Duration::from_secs(1));",
          "",
          "    for i in 0..20 {",
          "        let _permit = limiter.acquire().await;",
          "        println!(\"Executing task {}\", i);",
          "    }",
          "}"
        ],
        "tags": ["rust", "async", "rate-limiter", "tokio"],
        "author": "pyyupsk"
      }
    ]
  },
  {
    "categoryName": "Memory Management",
    "snippets": [
      {
        "title": "Custom Smart Pointer",
        "description": "Implementation of a custom reference-counted smart pointer with interior mutability",
        "code": [
          "use std::cell::UnsafeCell;",
          "use std::ops::{Deref, DerefMut};",
          "use std::sync::atomic::{AtomicUsize, Ordering};",
          "use std::sync::Arc;",
          "",
          "pub struct Interior<T> {",
          "    ref_count: AtomicUsize,",
          "    data: UnsafeCell<T>,",
          "}",
          "",
          "pub struct SmartPtr<T> {",
          "    ptr: Arc<Interior<T>>,",
          "}",
          "",
          "impl<T> SmartPtr<T> {",
          "    pub fn new(data: T) -> Self {",
          "        SmartPtr {",
          "            ptr: Arc::new(Interior {",
          "                ref_count: AtomicUsize::new(1),",
          "                data: UnsafeCell::new(data),",
          "            }),",
          "        }",
          "    }",
          "",
          "    pub fn get_ref_count(&self) -> usize {",
          "        self.ptr.ref_count.load(Ordering::SeqCst)",
          "    }",
          "}",
          "",
          "impl<T> Clone for SmartPtr<T> {",
          "    fn clone(&self) -> Self {",
          "        self.ptr.ref_count.fetch_add(1, Ordering::SeqCst);",
          "        SmartPtr {",
          "            ptr: Arc::clone(&self.ptr),",
          "        }",
          "    }",
          "}",
          "",
          "impl<T> Drop for SmartPtr<T> {",
          "    fn drop(&mut self) {",
          "        if self.ptr.ref_count.fetch_sub(1, Ordering::SeqCst) == 1 {",
          "            // Last reference is being dropped",
          "            unsafe {",
          "                drop(Box::from_raw(self.ptr.data.get()));",
          "            }",
          "        }",
          "    }",
          "}",
          "",
          "impl<T> Deref for SmartPtr<T> {",
          "    type Target = T;",
          "",
          "    fn deref(&self) -> &Self::Target {",
          "        unsafe { &*self.ptr.data.get() }",
          "    }",
          "}",
          "",
          "impl<T> DerefMut for SmartPtr<T> {",
          "    fn deref_mut(&mut self) -> &mut Self::Target {",
          "        unsafe { &mut *self.ptr.data.get() }",
          "    }",
          "}",
          "",
          "// Usage:",
          "let ptr = SmartPtr::new(42);",
          "let cloned = ptr.clone();",
          "assert_eq!(ptr.get_ref_count(), 2);",
          "assert_eq!(*ptr, 42);"
        ],
        "tags": ["rust", "smart-pointer", "memory-management", "unsafe"],
        "author": "pyyupsk"
      }
    ]
  }
]
